---
const images = (Astro.props.images ?? []) as string[];

---

<div class="room-slider" data-room-slider>
  {images.map((image, index) => (
    <figure class={`room-slide${index === 0 ? " is-active" : ""}`} data-room-slide>
      <img
        src={image}
        alt={`Dettaglio camera ${index + 1}`}
        loading={index === 0 ? "eager" : "lazy"}
        decoding="async"
        width="1200"
        height="900"
        sizes="(min-width: 1024px) 520px, (min-width: 640px) 80vw, 100vw"
      />
    </figure>
  ))}
  <div class="room-slider__controls">
    <button type="button" class="room-slider__btn" data-room-prev aria-label="Immagine precedente">
      <span>&larr;</span>
    </button>
    <button type="button" class="room-slider__btn" data-room-next aria-label="Immagine successiva">
      <span>&rarr;</span>
    </button>
  </div>
</div>

<style>
.room-slider {
  position: relative;
  overflow: hidden;
  border-radius: 24px;
  background: rgba(0, 0, 0, 0.85);
  aspect-ratio: 4 / 3;
  width: 100%;
  touch-action: pan-y;
}

.room-slide {
  position: absolute;
  inset: 0;
  opacity: 0;
  transition: opacity 0.7s ease, transform 0.7s ease;
  transform: scale(1.05);
}

.room-slide.is-active {
  opacity: 1;
  transform: scale(1);
  z-index: 1;
}

.room-slide img {
  width: 100%;
  height: 100%;
  object-fit: cover;
  border-radius: 24px;
}

.room-slider__controls {
  position: absolute;
  bottom: 18px;
  right: 18px;
  display: flex;
  gap: 0.75rem;
}

.room-slider__btn {
  width: 42px;
  height: 42px;
  display: grid;
  place-items: center;
  background: rgba(255, 255, 255, 0.85);
  border: none;
  border-radius: 999px;
  color: var(--color-primary-dark);
  font-weight: 600;
  font-size: 1.15rem;
  cursor: pointer;
  box-shadow: 0 14px 30px rgba(48, 34, 21, 0.22);
  transition: transform 0.2s ease, background 0.2s ease;
}

.room-slider__btn:hover {
  transform: translateY(-2px);
  background: #fff;
}

@media (max-width: 768px) {
  .room-slider {
    border-radius: 18px;
  }

  .room-slide img {
    border-radius: 18px;
  }
}
</style>

<script>
  (() => {
    if (typeof window === 'undefined') return;

    /**
     * @param {HTMLElement} slider
     * @returns {() => void | undefined}
     */
    const setupRoomSlider = (slider) => {
      const slides = slider.querySelectorAll('[data-room-slide]');
      const prevBtn = slider.querySelector('[data-room-prev]');
      const nextBtn = slider.querySelector('[data-room-next]');

      if (!slides.length || !prevBtn || !nextBtn) return undefined;

      let index = 0;
      /** @type {ReturnType<typeof setInterval> | undefined} */
      let autoplayId;

      /**
       * @param {number} value
       */
      const activate = (value) => {
        slides.forEach((slide, slideIndex) => {
          slide.classList.toggle('is-active', slideIndex === value);
        });
      };

      const showNext = () => {
        index = (index + 1) % slides.length;
        activate(index);
      };

      const showPrev = () => {
        index = (index - 1 + slides.length) % slides.length;
        activate(index);
      };

      const stopAutoPlay = () => {
        if (autoplayId) {
          clearInterval(autoplayId);
          autoplayId = undefined;
        }
      };

      const startAutoPlay = () => {
        if (slides.length <= 1 || autoplayId) return;
        autoplayId = setInterval(showNext, 5000);
      };

      const handleNext = () => {
        showNext();
        stopAutoPlay();
        startAutoPlay();
      };

      const handlePrev = () => {
        showPrev();
        stopAutoPlay();
        startAutoPlay();
      };

      const handleVisibility = () => {
        if (document.visibilityState === 'hidden') {
          stopAutoPlay();
        } else {
          startAutoPlay();
        }
      };

      const reducedMotionQuery = window.matchMedia('(prefers-reduced-motion: reduce)');
      /**
       * @param {MediaQueryList | MediaQueryListEvent} source
       */
      const handleMotionPreference = (source) => {
        const prefersReduced = typeof source.matches === 'boolean' ? source.matches : false;
        if (prefersReduced) {
          stopAutoPlay();
        } else {
          startAutoPlay();
        }
      };

      const swipeThreshold = 45;
      let activePointerId;
      let pointerStartX = 0;
      let pointerStartY = 0;
      let pointerLastX = 0;
      let pointerLastY = 0;
      let isPointerDown = false;

      const releasePointer = (event) => {
        if (typeof activePointerId !== 'number') return;
        if (typeof slider.releasePointerCapture === 'function') {
          try {
            slider.releasePointerCapture(activePointerId);
          } catch (error) {
            // Ignora eventuali errori sui browser che non supportano pointer capture.
          }
        }
        activePointerId = undefined;
        isPointerDown = false;
      };

      const handlePointerDown = (event) => {
        if (!event.isPrimary) return;
        if (event.pointerType === 'mouse' && event.button !== 0) return;
        isPointerDown = true;
        activePointerId = event.pointerId;
        pointerStartX = event.clientX;
        pointerStartY = event.clientY;
        pointerLastX = event.clientX;
        pointerLastY = event.clientY;
        if (typeof slider.setPointerCapture === 'function') {
          try {
            slider.setPointerCapture(activePointerId);
          } catch (error) {
            // Ignora eventuali errori sui browser che non supportano pointer capture.
          }
        }
        stopAutoPlay();
      };

      const handlePointerMove = (event) => {
        if (!isPointerDown || event.pointerId !== activePointerId) return;
        pointerLastX = event.clientX;
        pointerLastY = event.clientY;
      };

      const handlePointerEnd = (event) => {
        if (!isPointerDown || event.pointerId !== activePointerId) return;
        pointerLastX = event.clientX;
        pointerLastY = event.clientY;
        const deltaX = pointerLastX - pointerStartX;
        const deltaY = pointerLastY - pointerStartY;
        const isHorizontalGesture = Math.abs(deltaX) > Math.abs(deltaY);
        if (isHorizontalGesture && Math.abs(deltaX) > swipeThreshold) {
          if (deltaX < 0) {
            showNext();
          } else {
            showPrev();
          }
        }
        releasePointer(event);
        startAutoPlay();
      };

      const handlePointerCancel = (event) => {
        if (!isPointerDown || event.pointerId !== activePointerId) return;
        releasePointer(event);
        startAutoPlay();
      };

      const preventNativeDrag = (event) => {
        event.preventDefault();
      };

      prevBtn.addEventListener('click', handlePrev);
      nextBtn.addEventListener('click', handleNext);
      slider.addEventListener('mouseenter', stopAutoPlay);
      slider.addEventListener('mouseleave', startAutoPlay);
      slider.addEventListener('pointerdown', handlePointerDown);
      slider.addEventListener('pointermove', handlePointerMove);
      slider.addEventListener('pointerup', handlePointerEnd);
      slider.addEventListener('pointercancel', handlePointerCancel);
      slider.addEventListener('dragstart', preventNativeDrag);
      document.addEventListener('visibilitychange', handleVisibility);
      if (typeof reducedMotionQuery.addEventListener === 'function') {
        reducedMotionQuery.addEventListener('change', handleMotionPreference);
      } else if (typeof reducedMotionQuery.addListener === 'function') {
        reducedMotionQuery.addListener(handleMotionPreference);
      }

      activate(index);
      handleMotionPreference(reducedMotionQuery);

      return () => {
        stopAutoPlay();
        prevBtn.removeEventListener('click', handlePrev);
        nextBtn.removeEventListener('click', handleNext);
        slider.removeEventListener('mouseenter', stopAutoPlay);
        slider.removeEventListener('mouseleave', startAutoPlay);
        slider.removeEventListener('pointerdown', handlePointerDown);
        slider.removeEventListener('pointermove', handlePointerMove);
        slider.removeEventListener('pointerup', handlePointerEnd);
        slider.removeEventListener('pointercancel', handlePointerCancel);
        slider.removeEventListener('dragstart', preventNativeDrag);
        document.removeEventListener('visibilitychange', handleVisibility);
        if (typeof reducedMotionQuery.removeEventListener === 'function') {
          reducedMotionQuery.removeEventListener('change', handleMotionPreference);
        } else if (typeof reducedMotionQuery.removeListener === 'function') {
          reducedMotionQuery.removeListener(handleMotionPreference);
        }
      };
    };

    const init = () => {
      const sliders = document.querySelectorAll('[data-room-slider]');
      if (!sliders.length) return;

      /** @type {WeakMap<Element, () => void>} */
      const cleanupMap = new WeakMap();
      let observer;

      /**
       * @param {Element} slider
       */
      const mountSlider = (slider) => {
        if (cleanupMap.has(slider)) return;
        const cleanup = setupRoomSlider(slider);
        if (typeof cleanup === 'function') {
          cleanupMap.set(slider, cleanup);
        }
      };

      /**
       * @param {Element} slider
       */
      const unmountSlider = (slider) => {
        const cleanup = cleanupMap.get(slider);
        if (cleanup) {
          cleanup();
          cleanupMap.delete(slider);
        }
      };

      const enableInteractive = () => {
        if ('IntersectionObserver' in window) {
          if (observer) return;
          observer = new IntersectionObserver(
            (entries) => {
              entries.forEach((entry) => {
                if (entry.isIntersecting) {
                  mountSlider(entry.target);
                } else {
                  unmountSlider(entry.target);
                }
              });
            },
            { threshold: 0.2 }
          );

          sliders.forEach((slider) => observer.observe(slider));
        } else {
          sliders.forEach(mountSlider);
        }
      };

      const disableInteractive = () => {
        if (observer) {
          observer.disconnect();
          observer = undefined;
        }
        sliders.forEach(unmountSlider);
      };

      enableInteractive();

      const handlePageHide = () => {
        disableInteractive();
      };

      window.addEventListener('pagehide', handlePageHide, { once: true });
    };

    const start = () => {
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', init, { once: true });
      } else {
        init();
      }
    };

    if ('requestIdleCallback' in window) {
      window.requestIdleCallback(start, { timeout: 500 });
    } else {
      setTimeout(start, 200);
    }
  })();
</script>
