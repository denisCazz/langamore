---
const images = (Astro.props.images ?? []) as string[];

---

<div class="room-slider" data-room-slider>
  {images.map((image, index) => (
    <figure class={`room-slide${index === 0 ? " is-active" : ""}`} data-room-slide>
      <img
        src={image}
        alt={`Dettaglio camera ${index + 1}`}
        loading={index === 0 ? "eager" : "lazy"}
        decoding="async"
        width="1200"
        height="900"
        sizes="(min-width: 1024px) 520px, (min-width: 640px) 80vw, 100vw"
      />
    </figure>
  ))}
  <div class="room-slider__hint" data-room-hint aria-live="polite" aria-hidden="false">
    <span class="room-slider__hint-icon" aria-hidden="true">â‡†</span>
    <span class="room-slider__hint-text">Scorri</span>
  </div>
  <div class="room-slider__controls">
    <button type="button" class="room-slider__btn" data-room-prev aria-label="Immagine precedente">
      <span>&larr;</span>
    </button>
    <button type="button" class="room-slider__btn" data-room-next aria-label="Immagine successiva">
      <span>&rarr;</span>
    </button>
  </div>
</div>

<style>
.room-slider {
  position: relative;
  overflow: hidden;
  border-radius: 24px;
  background: rgba(0, 0, 0, 0.85);
  aspect-ratio: 4 / 3;
  width: 100%;
  touch-action: pan-y;
}

.room-slide {
  position: absolute;
  inset: 0;
  opacity: 0;
  transition: opacity 0.7s ease, transform 0.7s ease;
  transform: scale(1.05);
}

.room-slide.is-active {
  opacity: 1;
  transform: scale(1);
  z-index: 1;
}

.room-slide img {
  width: 100%;
  height: 100%;
  object-fit: cover;
  border-radius: 24px;
}

.room-slider__controls {
  position: absolute;
  bottom: 18px;
  right: 18px;
  display: flex;
  gap: 0.75rem;
}

.room-slider__hint {
  position: absolute;
  bottom: 18px;
  left: 50%;
  transform: translate(-50%, 0);
  display: inline-flex;
  align-items: center;
  gap: 0.55rem;
  padding: 0.55rem 1rem;
  background: rgba(255, 255, 255, 0.9);
  border-radius: 999px;
  border: 1px solid rgba(255, 255, 255, 0.7);
  color: var(--color-primary-dark);
  font-size: 0.92rem;
  font-weight: 600;
  letter-spacing: 0.025em;
  box-shadow: 0 16px 32px rgba(48, 34, 21, 0.2);
  backdrop-filter: blur(12px);
  animation: room-slider-hint-wave 2.6s ease-in-out infinite, room-slider-hint-fade 5.4s ease-in-out infinite;
  transition: opacity 0.35s ease, transform 0.35s ease;
  will-change: transform, opacity;
  z-index: 2;
  pointer-events: none;
}

.room-slider__hint-icon {
  display: inline-grid;
  place-items: center;
  width: 1.7rem;
  height: 1.7rem;
  font-size: 1.05rem;
  line-height: 1;
  color: var(--color-primary-dark);
  background: rgba(248, 229, 208, 0.7);
  border-radius: 999px;
  animation: room-slider-hint-icon 1.7s ease-in-out infinite;
}

.room-slider__hint-text {
  text-transform: uppercase;
  font-size: 0.78rem;
  line-height: 1;
}

.room-slider__hint.is-hidden {
  opacity: 0;
  transform: translate(-50%, 24px);
  pointer-events: none;
  visibility: hidden;
  animation: none;
}

@keyframes room-slider-hint-wave {
  0%,
  100% {
    transform: translate(-50%, 0);
  }
  45% {
    transform: translate(calc(-50% - 15px), 0);
  }
  65% {
    transform: translate(calc(-50% + 15px), 0);
  }
}

@keyframes room-slider-hint-fade {
  0%,
  12%,
  88%,
  100% {
    opacity: 1;
  }
  50% {
    opacity: 0.78;
  }
}

@keyframes room-slider-hint-icon {
  0%,
  100% {
    transform: translateX(0);
  }
  45% {
    transform: translateX(-7px);
  }
  65% {
    transform: translateX(7px);
  }
}

@media (prefers-reduced-motion: reduce) {
  .room-slider__hint,
  .room-slider__hint-icon {
    animation: none;
  }
}

.room-slider__btn {
  width: 42px;
  height: 42px;
  display: grid;
  place-items: center;
  background: rgba(255, 255, 255, 0.85);
  border: none;
  border-radius: 999px;
  color: var(--color-primary-dark);
  font-weight: 600;
  font-size: 1.15rem;
  cursor: pointer;
  box-shadow: 0 14px 30px rgba(48, 34, 21, 0.22);
  transition: transform 0.2s ease, background 0.2s ease;
}

.room-slider__btn:hover {
  transform: translateY(-2px);
  background: #fff;
}

@media (max-width: 768px) {
  .room-slider {
    border-radius: 18px;
  }

  .room-slide img {
    border-radius: 18px;
  }

  .room-slider__hint {
    bottom: 14px;
    font-size: 0.84rem;
    padding: 0.45rem 0.85rem;
    gap: 0.45rem;
  }

  .room-slider__hint-text {
    font-size: 0.72rem;
  }
}
</style>

<script>
  (() => {
    if (typeof window === 'undefined') return;

    /**
     * @param {HTMLElement} slider
     * @returns {() => void | undefined}
     */
    const setupRoomSlider = (slider) => {
      const slides = slider.querySelectorAll('[data-room-slide]');
      const prevBtn = slider.querySelector('[data-room-prev]');
      const nextBtn = slider.querySelector('[data-room-next]');
      const hint = slider.querySelector('[data-room-hint]');

      if (!slides.length || !prevBtn || !nextBtn) return undefined;

      let index = 0;
      /** @type {ReturnType<typeof setInterval> | undefined} */
      let autoplayId;
      /** @type {ReturnType<typeof setTimeout> | undefined} */
      let hintTimer;
      let hintDismissed = false;

      if (hint) {
        hint.classList.remove('is-hidden');
        hint.setAttribute('aria-hidden', 'false');
      }

      const hideHint = () => {
        if (!hint || hintDismissed) return;
        hintDismissed = true;
        hint.classList.add('is-hidden');
        hint.setAttribute('aria-hidden', 'true');
        if (hintTimer) {
          clearTimeout(hintTimer);
          hintTimer = undefined;
        }
      };

      const scheduleHintDismiss = () => {
        if (!hint || hintDismissed || hintTimer) return;
        hintTimer = window.setTimeout(() => {
          hintTimer = undefined;
          hideHint();
        }, 5400);
      };

      /**
       * @param {number} value
       */
      const activate = (value) => {
        slides.forEach((slide, slideIndex) => {
          slide.classList.toggle('is-active', slideIndex === value);
        });
      };

      const showNext = () => {
        index = (index + 1) % slides.length;
        activate(index);
      };

      const showPrev = () => {
        index = (index - 1 + slides.length) % slides.length;
        activate(index);
      };

      const stopAutoPlay = () => {
        if (autoplayId) {
          clearInterval(autoplayId);
          autoplayId = undefined;
        }
      };

      const startAutoPlay = () => {
        if (slides.length <= 1 || autoplayId) return;
        autoplayId = setInterval(showNext, 5000);
      };

      const handleNext = () => {
        showNext();
        stopAutoPlay();
        startAutoPlay();
        hideHint();
      };

      const handlePrev = () => {
        showPrev();
        stopAutoPlay();
        startAutoPlay();
        hideHint();
      };

      const handleVisibility = () => {
        if (document.visibilityState === 'hidden') {
          stopAutoPlay();
        } else {
          startAutoPlay();
        }
      };

      const reducedMotionQuery = window.matchMedia('(prefers-reduced-motion: reduce)');
      /**
       * @param {MediaQueryList | MediaQueryListEvent} source
       */
      const handleMotionPreference = (source) => {
        const prefersReduced = typeof source.matches === 'boolean' ? source.matches : false;
        if (prefersReduced) {
          stopAutoPlay();
        } else {
          startAutoPlay();
        }
      };

      const swipeThreshold = 45;
      let activePointerId;
      let pointerStartX = 0;
      let pointerStartY = 0;
      let pointerLastX = 0;
      let pointerLastY = 0;
      let isPointerDown = false;

      const releasePointer = (event) => {
        if (typeof activePointerId !== 'number') return;
        if (typeof slider.releasePointerCapture === 'function') {
          try {
            slider.releasePointerCapture(activePointerId);
          } catch (error) {
            // Ignora eventuali errori sui browser che non supportano pointer capture.
          }
        }
        activePointerId = undefined;
        isPointerDown = false;
      };

      const handlePointerDown = (event) => {
        if (!event.isPrimary) return;
        if (event.pointerType === 'mouse' && event.button !== 0) return;
        isPointerDown = true;
        activePointerId = event.pointerId;
        pointerStartX = event.clientX;
        pointerStartY = event.clientY;
        pointerLastX = event.clientX;
        pointerLastY = event.clientY;
        hideHint();
        if (typeof slider.setPointerCapture === 'function') {
          try {
            slider.setPointerCapture(activePointerId);
          } catch (error) {
            // Ignora eventuali errori sui browser che non supportano pointer capture.
          }
        }
        stopAutoPlay();
      };

      const handlePointerMove = (event) => {
        if (!isPointerDown || event.pointerId !== activePointerId) return;
        pointerLastX = event.clientX;
        pointerLastY = event.clientY;
      };

      const handlePointerEnd = (event) => {
        if (!isPointerDown || event.pointerId !== activePointerId) return;
        pointerLastX = event.clientX;
        pointerLastY = event.clientY;
        const deltaX = pointerLastX - pointerStartX;
        const deltaY = pointerLastY - pointerStartY;
        const isHorizontalGesture = Math.abs(deltaX) > Math.abs(deltaY);
        if (isHorizontalGesture && Math.abs(deltaX) > swipeThreshold) {
          if (deltaX < 0) {
            showNext();
          } else {
            showPrev();
          }
        }
        releasePointer(event);
        startAutoPlay();
      };

      const handlePointerCancel = (event) => {
        if (!isPointerDown || event.pointerId !== activePointerId) return;
        releasePointer(event);
        startAutoPlay();
      };

      const preventNativeDrag = (event) => {
        event.preventDefault();
      };

      const handleFocusIn = () => {
        hideHint();
      };

      prevBtn.addEventListener('click', handlePrev);
      nextBtn.addEventListener('click', handleNext);
      slider.addEventListener('mouseenter', stopAutoPlay);
      slider.addEventListener('mouseleave', startAutoPlay);
      slider.addEventListener('pointerdown', handlePointerDown);
      slider.addEventListener('pointermove', handlePointerMove);
      slider.addEventListener('pointerup', handlePointerEnd);
      slider.addEventListener('pointercancel', handlePointerCancel);
      slider.addEventListener('dragstart', preventNativeDrag);
      slider.addEventListener('focusin', handleFocusIn);
      document.addEventListener('visibilitychange', handleVisibility);
      if (typeof reducedMotionQuery.addEventListener === 'function') {
        reducedMotionQuery.addEventListener('change', handleMotionPreference);
      } else if (typeof reducedMotionQuery.addListener === 'function') {
        reducedMotionQuery.addListener(handleMotionPreference);
      }

      activate(index);
      handleMotionPreference(reducedMotionQuery);
      scheduleHintDismiss();

      return () => {
        stopAutoPlay();
        prevBtn.removeEventListener('click', handlePrev);
        nextBtn.removeEventListener('click', handleNext);
        slider.removeEventListener('mouseenter', stopAutoPlay);
        slider.removeEventListener('mouseleave', startAutoPlay);
        slider.removeEventListener('pointerdown', handlePointerDown);
        slider.removeEventListener('pointermove', handlePointerMove);
        slider.removeEventListener('pointerup', handlePointerEnd);
        slider.removeEventListener('pointercancel', handlePointerCancel);
        slider.removeEventListener('dragstart', preventNativeDrag);
        slider.removeEventListener('focusin', handleFocusIn);
        document.removeEventListener('visibilitychange', handleVisibility);
        if (typeof reducedMotionQuery.removeEventListener === 'function') {
          reducedMotionQuery.removeEventListener('change', handleMotionPreference);
        } else if (typeof reducedMotionQuery.removeListener === 'function') {
          reducedMotionQuery.removeListener(handleMotionPreference);
        }
        if (hintTimer) {
          clearTimeout(hintTimer);
          hintTimer = undefined;
        }
      };
    };

    const init = () => {
      const sliders = document.querySelectorAll('[data-room-slider]');
      if (!sliders.length) return;

      /** @type {WeakMap<Element, () => void>} */
      const cleanupMap = new WeakMap();
      let observer;

      /**
       * @param {Element} slider
       */
      const mountSlider = (slider) => {
        if (cleanupMap.has(slider)) return;
        const cleanup = setupRoomSlider(slider);
        if (typeof cleanup === 'function') {
          cleanupMap.set(slider, cleanup);
        }
      };

      /**
       * @param {Element} slider
       */
      const unmountSlider = (slider) => {
        const cleanup = cleanupMap.get(slider);
        if (cleanup) {
          cleanup();
          cleanupMap.delete(slider);
        }
      };

      const enableInteractive = () => {
        if ('IntersectionObserver' in window) {
          if (observer) return;
          observer = new IntersectionObserver(
            (entries) => {
              entries.forEach((entry) => {
                if (entry.isIntersecting) {
                  mountSlider(entry.target);
                } else {
                  unmountSlider(entry.target);
                }
              });
            },
            { threshold: 0.2 }
          );

          sliders.forEach((slider) => observer.observe(slider));
        } else {
          sliders.forEach(mountSlider);
        }
      };

      const disableInteractive = () => {
        if (observer) {
          observer.disconnect();
          observer = undefined;
        }
        sliders.forEach(unmountSlider);
      };

      enableInteractive();

      const handlePageHide = () => {
        disableInteractive();
      };

      window.addEventListener('pagehide', handlePageHide, { once: true });
    };

    const start = () => {
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', init, { once: true });
      } else {
        init();
      }
    };

    if ('requestIdleCallback' in window) {
      window.requestIdleCallback(start, { timeout: 500 });
    } else {
      setTimeout(start, 200);
    }
  })();
</script>
