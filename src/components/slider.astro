---
const imagesSrc = (Astro.props.src ?? []) as string[];
const imagesAlt = (Astro.props.alt ?? []) as string[];

---

<div class="hero-slider" data-slider>
  {imagesSrc.map((image, index) => (
    <div class={`hero-slide${index === 0 ? " is-active" : ""}`} data-slide>
      <img
        src={image}
        alt={imagesAlt[index] ?? ""}
        class="hero-slide__image"
        loading={index === 0 ? "eager" : "lazy"}
  decoding="async"
        width="1280"
        height="720"
        sizes="(min-width: 1024px) 640px, (min-width: 640px) 80vw, 100vw"
      />
      <div class="hero-slide__overlay"></div>
    </div>
  ))}
  <div class="hero-slider__indicators" data-slider-indicators>
    {imagesSrc.map((_, index) => (
      <button
        type="button"
        class={`hero-indicator${index === 0 ? " is-active" : ""}`}
        data-slider-indicator
        aria-label={`Mostra slide ${index + 1}`}
      ></button>
    ))}
  </div>
</div>

<style>
.hero-slider {
  position: relative;
  overflow: hidden;
  border-radius: 24px;
  isolation: isolate;
  aspect-ratio: 16 / 9;
  width: 100%;
  background: #1f2937;
  box-shadow: 0 30px 60px rgba(31, 41, 55, 0.25);
}

.hero-slide {
  position: absolute;
  inset: 0;
  opacity: 0;
  transition: opacity 1.1s ease, transform 1.1s ease;
  transform: scale(1.05);
}

.hero-slide.is-active {
  opacity: 1;
  transform: scale(1);
  z-index: 1;
}

.hero-slide__image {
  width: 100%;
  height: 100%;
  object-fit: cover;
}

.hero-slide__overlay {
  position: absolute;
  inset: 0;
  background: linear-gradient(120deg, rgba(17, 24, 39, 0.45) 0%, rgba(17, 24, 39, 0.15) 60%, rgba(255, 255, 255, 0) 100%);
}

.hero-slider__indicators {
  position: absolute;
  bottom: 22px;
  left: 50%;
  transform: translateX(-50%);
  display: inline-flex;
  gap: 0.75rem;
  padding: 0.4rem 0.75rem;
  background: rgba(255, 255, 255, 0.55);
  border-radius: 999px;
  backdrop-filter: blur(10px);
}

.hero-indicator {
  width: 10px;
  height: 10px;
  border-radius: 999px;
  border: none;
  background: rgba(139, 93, 55, 0.25);
  transition: transform 0.3s ease, background 0.3s ease;
  cursor: pointer;
}

.hero-indicator.is-active {
  background: var(--color-primary);
  transform: scale(1.35);
}

@media (max-width: 768px) {
  .hero-slider {
    border-radius: 18px;
    aspect-ratio: 4 / 3;
  }

  .hero-slider__indicators {
    bottom: 16px;
  }
}
</style>

<script>
  (() => {
    if (typeof window === 'undefined') return;

    /**
     * @param {HTMLElement} slider
     * @returns {() => void | undefined}
     */
    const setupSlider = (slider) => {
      const slides = slider.querySelectorAll('[data-slide]');
      const indicators = slider.querySelectorAll('[data-slider-indicator]');
      if (!slides.length) return undefined;

      let current = 0;
  /** @type {ReturnType<typeof setInterval> | undefined} */
  let autoplayId;

      /**
       * @param {number} index
       */
      const activateSlide = (index) => {
        slides.forEach((slide, slideIndex) => {
          slide.classList.toggle('is-active', slideIndex === index);
        });
        indicators.forEach((indicator, indicatorIndex) => {
          indicator.classList.toggle('is-active', indicatorIndex === index);
        });
      };

      const goTo = (index) => {
        current = index;
        activateSlide(current);
      };

      const showNext = () => {
        goTo((current + 1) % slides.length);
      };

      const stopAutoPlay = () => {
        if (autoplayId) {
          clearInterval(autoplayId);
          autoplayId = undefined;
        }
      };

      const startAutoPlay = () => {
        if (slides.length <= 1 || autoplayId) return;
        autoplayId = setInterval(showNext, 4500);
      };

  /** @type {Map<Element, () => void>} */
  const indicatorHandlers = new Map();
      indicators.forEach((indicator, index) => {
        const handler = () => {
          goTo(index);
          stopAutoPlay();
          startAutoPlay();
        };
        indicator.addEventListener('click', handler);
        indicatorHandlers.set(indicator, handler);
      });

      const handleVisibility = () => {
        if (document.visibilityState === 'hidden') {
          stopAutoPlay();
        } else {
          startAutoPlay();
        }
      };

      const reducedMotionQuery = window.matchMedia('(prefers-reduced-motion: reduce)');
      /**
       * @param {MediaQueryList | MediaQueryListEvent} source
       */
      const handleMotionPreference = (source) => {
        const prefersReduced = typeof source.matches === 'boolean' ? source.matches : false;
        if (prefersReduced) {
          stopAutoPlay();
        } else {
          startAutoPlay();
        }
      };

      slider.addEventListener('mouseenter', stopAutoPlay);
      slider.addEventListener('mouseleave', startAutoPlay);
      document.addEventListener('visibilitychange', handleVisibility);
      if (typeof reducedMotionQuery.addEventListener === 'function') {
        reducedMotionQuery.addEventListener('change', handleMotionPreference);
      } else if (typeof reducedMotionQuery.addListener === 'function') {
        reducedMotionQuery.addListener(handleMotionPreference);
      }

      activateSlide(current);
      handleMotionPreference(reducedMotionQuery);

      return () => {
        stopAutoPlay();
        slider.removeEventListener('mouseenter', stopAutoPlay);
        slider.removeEventListener('mouseleave', startAutoPlay);
        document.removeEventListener('visibilitychange', handleVisibility);
        if (typeof reducedMotionQuery.removeEventListener === 'function') {
          reducedMotionQuery.removeEventListener('change', handleMotionPreference);
        } else if (typeof reducedMotionQuery.removeListener === 'function') {
          reducedMotionQuery.removeListener(handleMotionPreference);
        }
        indicatorHandlers.forEach((handler, indicator) => {
          indicator.removeEventListener('click', handler);
        });
        indicatorHandlers.clear();
      };
    };

    const init = () => {
      const sliders = document.querySelectorAll('[data-slider]');
      if (!sliders.length) return;

      /** @type {WeakMap<Element, () => void>} */
      const cleanupMap = new WeakMap();
      let observer;

      /**
       * @param {Element} slider
       */
      const mountSlider = (slider) => {
        if (cleanupMap.has(slider)) return;
        const cleanup = setupSlider(slider);
        if (typeof cleanup === 'function') {
          cleanupMap.set(slider, cleanup);
        }
      };

      /**
       * @param {Element} slider
       */
      const unmountSlider = (slider) => {
        const cleanup = cleanupMap.get(slider);
        if (cleanup) {
          cleanup();
          cleanupMap.delete(slider);
        }
      };

      const enableInteractive = () => {
        if ('IntersectionObserver' in window) {
          if (observer) return;
          observer = new IntersectionObserver(
            (entries) => {
              entries.forEach((entry) => {
                if (entry.isIntersecting) {
                  mountSlider(entry.target);
                } else {
                  unmountSlider(entry.target);
                }
              });
            },
            { threshold: 0.3 }
          );

          sliders.forEach((slider) => observer.observe(slider));
        } else {
          sliders.forEach(mountSlider);
        }
      };

      const disableInteractive = () => {
        if (observer) {
          observer.disconnect();
          observer = undefined;
        }
        sliders.forEach(unmountSlider);
      };

      const desktopQuery = window.matchMedia('(min-width: 769px)');
      /**
       * @param {boolean} matches
       */
      const handleViewport = (matches) => {
        if (matches) {
          enableInteractive();
        } else {
          disableInteractive();
        }
      };

      handleViewport(desktopQuery.matches);

      const onViewportChange = (event) => handleViewport(event.matches);
      if (typeof desktopQuery.addEventListener === 'function') {
        desktopQuery.addEventListener('change', onViewportChange);
      } else if (typeof desktopQuery.addListener === 'function') {
        desktopQuery.addListener(onViewportChange);
      }
    };

    const start = () => {
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', init, { once: true });
      } else {
        init();
      }
    };

    if ('requestIdleCallback' in window) {
      window.requestIdleCallback(start, { timeout: 500 });
    } else {
      setTimeout(start, 200);
    }
  })();
</script>
